From 8cc523b539cb06e5314c9660fc23b6f7f89e9e09 Mon Sep 17 00:00:00 2001
From: Frode <Frode@FC>
Date: Sun, 2 May 2010 10:13:20 +0200
Subject: [PATCH 4/5] Escaping of delimiters ('?'), support for tracking current position in file
 Removed dependency on commons-lang, io

---
 .../larm/edifact/EdifactParserException.java       |   22 ++++
 .../no/statnett/larm/edifact/ParserContext.java    |  104 ++++++++++++++++++++
 2 files changed, 126 insertions(+), 0 deletions(-)
 create mode 100644 larm-ediel-parser/src/main/java/no/statnett/larm/edifact/EdifactParserException.java
 create mode 100644 larm-ediel-parser/src/main/java/no/statnett/larm/edifact/ParserContext.java

diff --git a/larm-ediel-parser/src/main/java/no/statnett/larm/edifact/EdifactParserException.java b/larm-ediel-parser/src/main/java/no/statnett/larm/edifact/EdifactParserException.java
new file mode 100644
index 0000000..9bb7b97
--- /dev/null
+++ b/larm-ediel-parser/src/main/java/no/statnett/larm/edifact/EdifactParserException.java
@@ -0,0 +1,22 @@
+package no.statnett.larm.edifact;
+
+public class EdifactParserException extends RuntimeException {
+
+	private static final long serialVersionUID = -8743452980063980177L;
+
+	EdifactParserException(String message) {
+		super(message);
+	}
+
+	EdifactParserException(ParserContext ctx, String message) {
+		super(message + ": " + ctx.formatPosition());
+	}
+
+	EdifactParserException(String message, Throwable t) {
+		super(message, t);
+	}
+
+	EdifactParserException(ParserContext ctx, Throwable t) {
+		super(t.getMessage() + ": parsing at " + ctx.formatPosition(), t);
+	}
+}
diff --git a/larm-ediel-parser/src/main/java/no/statnett/larm/edifact/ParserContext.java b/larm-ediel-parser/src/main/java/no/statnett/larm/edifact/ParserContext.java
new file mode 100644
index 0000000..0db1d65
--- /dev/null
+++ b/larm-ediel-parser/src/main/java/no/statnett/larm/edifact/ParserContext.java
@@ -0,0 +1,104 @@
+package no.statnett.larm.edifact;
+
+import java.io.IOException;
+import java.io.Reader;
+
+/**
+ * Track context while parsing message, including delimiters, position in
+ * message.
+ */
+class ParserContext {
+	private static final char NULL_CHAR = 0;
+
+	char componentDataElementSeparator = ':';
+	char dataElementSeparator = '+';
+	char decimalSeparator = '.';
+	char releaseIndicator = '?';
+	char segmentTerminator = '\'';
+
+	boolean hasReadFirst = false;
+
+	/* cyclic buffer tracking last read characters. */
+	private final char[] lastRead;
+	private long lastReadCounter = -1;
+
+	int lineNumber, columnNumber, segmentNumber;
+
+	String currentSegment, pushedBackSegment;
+
+	private char prev = NULL_CHAR;
+
+	ParserContext(int lastReadBufferSize) {
+		this.lastRead = new char[lastReadBufferSize];
+	}
+
+	String formatPosition() {
+		final String msg = "(line:%s, col:%s, segment:%s) last parsed: [%s]";
+		return String.format(msg, lineNumber, columnNumber, segmentNumber, lastRead());
+	}
+
+	void initSeparators(final String unaSegment) {
+		if (unaSegment != null && unaSegment.length() > 5) {
+			componentDataElementSeparator = unaSegment.charAt(0);
+			dataElementSeparator = unaSegment.charAt(1);
+			decimalSeparator = unaSegment.charAt(2);
+			releaseIndicator = unaSegment.charAt(3);
+			// 4 - reserved for future use
+			segmentTerminator = unaSegment.charAt(5);
+		}
+	}
+
+	String lastRead() {
+		long charsRead = lastReadCounter + 1;
+		int length = (int) Math.min((long) lastRead.length, charsRead);
+		char[] lastReadChars = new char[length];
+		for (int i = 1; i <= length; i++) {
+			lastReadChars[length - i] = lastRead[(int) ((charsRead - i) % lastRead.length)];
+		}
+		return new String(lastReadChars);
+
+	}
+
+	char lastReadChar() {
+		return prev;
+	}
+
+	String popCurrent() {
+		if (pushedBackSegment != null) {
+			currentSegment = pushedBackSegment;
+			pushedBackSegment = null;
+			return currentSegment;
+		}
+		return null;
+	}
+
+	void pushBack() {
+		pushedBackSegment = currentSegment;
+	}
+
+	int readChar(final Reader reader) throws IOException {
+		int c = reader.read();
+		trackPosition(c);
+		return c;
+	}
+
+	private void trackPosition(final int c) {
+		columnNumber++;
+
+		if (prev == releaseIndicator) {
+			// reset so escaping itself (e.g '??') won't escape next char
+			prev = NULL_CHAR;
+		} else if (c == segmentTerminator) {
+			segmentNumber++;
+		} else if (c == '\n' && prev != '\r') {
+			lineNumber++;
+			columnNumber = 0;
+		} else if (c == '\r') {
+			lineNumber++;
+			columnNumber = 0;
+		}
+
+		prev = (char) c;
+		lastRead[(int) (++lastReadCounter % lastRead.length)] = prev;
+	}
+}
-- 
1.7.0.2.msysgit.0

